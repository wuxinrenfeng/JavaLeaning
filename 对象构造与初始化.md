### 对象构造与初始化

#### 构造方法

* 构造方法（constructor）

  * 对象都有构造方法
  * 如果没有，编译器加一个**default**构造方法

  > 思考：抽象类（abstract）有没有构造方法？

#### 调用本类或父类的构造方法

* 调用本类或父类的构造方法
  * **this** 调用本类的其他构造方法
  * **super** 调用直接父类的构造方法
  * **this** 或 **super** 要放在第一条语句，且只能够有一条
* 如果没有 **this** 及 **super** ，则**编译器自动加上 super()**,即调用直接父类不带参数的构造方法
* 因为必须**令所有父类的构造方法都得到调用**，否则整个对象的构建就可能不正确

#### 一个问题

```java
Class A{
    A(int a){}
}
Class B extends A{
    B(String s){}  //编译不能够通过
}
```

* 编译器会自动调用`B(String s){super();}`出错
* 解决方法
  * 在B的构造方法中，加入`super(3);`
  * 在A中加入一个不带参数的构造方法 `A(){}`
  * 去掉A中全部的构造方法，则编译器会自动加入一个不带参数的构造方法，称为默认的构造方法

#### 创建对象时初始化

​     ` p new Person(){{age = 18;name = "黎明";}};`

* 这样可以针对没有相应构造函数，但又要赋值

  > 注意要用双括号

#### 实例初始化与静态初始化

* 实例初始化（Instance Initializers）

* 在类中直接写

  * `{   语句 ...}`
  * 实例初始化，先于构造方法{}中的语句执行

* 静态初始化（Static Initializers）

  * `static{    语句... }`

  * 静态初始化，在第一次使用这个类时要执行

  * 但其执行的具体时机是不确定的

    > 可以肯定地是：总是先于实例的初始化

#### 构造方法的执行过程

* 构造方法的执行过程遵照以下步骤
  * 调用本类或父类的构造方法，直至最高一层（Object）
  * 按照声明顺序执行字段的初始化赋值
  * 执行构造函数中的各语句

> 先父类构造，再本类成员赋值，最后执行构造方法中的语句

