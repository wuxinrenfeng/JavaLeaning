### JVM内存模型（入门）

#### 概述

JVM 入门，想要学习 JVM，必须先得了解JVM内存模型

#### 内存划分

Java 虚拟机按照运行时内存使用区域划分

![2843224-f692a4b1c13b2158](C:\Users\Tao\Desktop\Photo album\文章插图\2843224-f692a4b1c13b2158.png)

| 区域          | 是否线程共享 | 是否会内存溢出 |
| ------------- | ------------ | -------------- |
| 程序计数器    | 否           | 不会           |
| Java 虚拟机栈 | 否           | 会             |
| 本地方法栈    | 否           | 会             |
| 堆            | 是           | 会             |
| 方法区        | 是           | 会             |

#### 程序计数器（Program Counter Register）

程序计数器就是记录当前线程执行程序的位置，改变计数器的值来确定执行的下一条指令，比如循环、分支、方法跳转、异常处理，线程恢复都是依赖程序计数器来完成。

 Java虚拟机多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。为了线程切换能恢复到正确的位置，每条线程都需要一个独立的程序计数器，所以它是**线程私有**的。

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

#### Java 虚拟机（VM Stack）

Java虚拟机栈是**线程私有**，生命周期与线程相同。创建线程的时候就会创建一个 Java 虚拟机栈。

虚拟机执行 Java 程序的时候，每个方法都会创建一个栈帧，栈帧存放在 Java 虚拟机栈中，通过压栈出栈的方式进行方法调用。

栈帧又分为以下几个区域

* 局部变量表
* 操作数栈
* 动态连接
* 方法出口

平时我们所说的变量存在栈中，这句话说的不太严谨，应该说局部变量存放在 Java 虚拟机栈的局部变量表中。

Java 的8版本中基本类型的局部变量的值存放在虚拟机栈的局部变量表中，如果是引用型的变量，则只存储对象的引用地址。

> 注意：当用户请求web服务器，每个请求开启一个线程负责用户的响应计算（每个线程分配一个虚拟机栈空间），如果并发量大时，可能会导致内存溢出（OutOfMemoneyError），可以适当的把每个虚拟机栈的大小适当调小一点，减少内存的使用量来提高系统的并发量。
>
> 当栈空间调小以后，又会引发方法调用深度的的问题。因为，每个方法都会生成一个栈帧，如果方法调用深度很深就意味着，栈里面存放大量的栈帧，可能导致栈内存溢出（StackOverFlowError）。

#### 本地方法栈（Native Method Stack）

本地方法栈 为虚拟机使用到本地方法服务（native）。本地方法栈为线程私有，功能和虚拟机栈非常类似。线程在调用本地方法时，来存储本地方法的局部变量表，本地方法的操作数栈等等信息。

> 本地方法：是非 Java 语言实现的方法，例如，Java调用C语言，来操作某些硬件信息

#### 堆（Heap）

堆是被所有**线程共享**的区域，实在虚拟机启动时创建的。堆里面存放的都是**对象的实例**（new 出来的对象都存在堆中）。

我们平常所说的垃圾回收，主要回收的就是堆区。为了提升垃圾回收的性能，又把堆分成两块区**新生代（young）**和**年老代（old）**，更细一点划分新生代又可划分为**Eden**区和2个**Survivor**区（**From Survivor**和**To Survivor**）。

![2843224-fb470dbc5c4296ac](C:\Users\Tao\Desktop\Photo album\文章插图\2843224-fb470dbc5c4296ac.png)

* **Eden：**新创建的对象存放在Eden区
* **From Survivor和To Survivor：**保存新生代gc后还存活的对象。（使用复制算法，导致有一个Survivor空间浪费）Hotspot虚拟机新生代Eden和Survivor的大小比值为4：1，因为有两个Survivor，所以Eden:From Survivor:To Survivor比值为8：1：1。
* **老年代：**对象存活时间比较长（经过多次新生代的垃圾收集，默认是15次）的对象则进入老年的。
* 当堆中分配的对象实例过多，且大部分对象都在使用，就会报内存溢出异常（**OutOfMemoneyError**）。

#### 方法区

方法区是被所有**线程共享**区域，用于存放**已被虚拟机加载**的类信息，常量，静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（**permanment generation**）

永久代也会垃圾回收，主要针对常量池回收，类型卸载（比如反射生成大量的临时使用的Class等信息）。

常量池用于存放**编译期**生成的各种字节码和符号引用，常量池具有一定的动态性，里面可以存放编译期生成的常量；**运行期间**的常量也可以添加进入常量池中，比如**string**的**intern()**方法。

当方法区满时，无法在分配空间，就会抛出内存溢出的异常（**OutOfMemoneyError**）。
java8中已经没有方法区了，取而代之的是元空间（**Metaspace**）。

#### 直接内存

**直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域**，但是这部分内存也被频繁地使用，而且也可能导致**OutOfMemoryError**异常出现。

 JDK1.4加的NIO中，ByteBuffer有个方法是**allocateDirect(int capacity)** ，这是一种基于通道（**Channel**）与缓冲区（**Buffer**）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。
